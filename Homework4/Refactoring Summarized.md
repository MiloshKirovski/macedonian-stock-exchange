# Сумаризација на Промени

Деталните рефакторирачки промени се дадени во продолжение во 3 секции. Едната се фокусира на Spring делот, друга на React делот и третата ги опфаќа сите три креирани микросервиси од Flask апликацијата (сега 3 посебни апликации) во еден дел.

Крајната добиена архитектура (контејнеризирана и поставена на Cloud) е следната:

![stocks_architecture_final.png](C:\Users\Milos\OneDrive\Desktop\stocks_architecture_final.png)



## Flask APP Рефакторирање

**Класата `ModelLoaderFactory` и имплементацијата `SpecificModelLoaderFactory`:**

**Пред факторирање**: Логиката за вчитување на скаларите и моделите за секоја компанија беше вградена во функцијата `predict_next_price`.  
**По факторирање**: Креиравме нова класа, `ModelLoaderFactory`, која управува со вчитувањето на скаларите и моделите за секоја компанија. Ова овозможува повторна употреба и ја централизира логиката за вчитување на неопходните ресурси (скалер и модел). Методата `get_scaler_and_model` е одговорна за вчитување на скаларот и моделот од нивните соодветни директории, користејќи го името на компанијата.  
**Причина**: Оваа разделба овозможува почист и по-поделен код а со тоа и го поедноставува процесот на вчитување модели за различни компании.  
*Овдека го користевме фабричкиот метод (Factory Method) за да ја инкапсулираме логиката за креирање објекти (скалари и модели) на едно место, што го прави процесот пофлексибилен и повторно употреблив низ целиот систем.*

**Глобален фабрички примерок:**

Инстанциравме глобален примерок на `ModelLoaderFactory` класата. Овој објект потоа се користи ( `predict_next_price`) за да ги вчита скаларот и моделот за секоја компанија како и низ целата апликација.  
*Тука ја разгледувавме шемата Factory како идеален пример за оваа ситуација, каде што само еден примерок на `SpecificModelLoaderFactory` се креира и користи низ целата апликација, обезбедувајќи едно место за контрола на логиката за вчитување на модели. Ова помага при користење на моделите од различните нишки на апликацијата како и неконфиктно вчитување.* 

Ова е направено во Python, па немавме многу простор за инстанцирање на класите како апстрактни, но шемата е пратена како што би била во објектно ориентиран Python Flask проект.

**Подобрувања во ракувањето со грешки:**

**Пред факторирање**: Имаше некои генерални печатања кои симулираа ракување со грешки, но не постоеше специфично ракување за случаи како недостасувачки модели или скалари.  
**По факторирање**: Методата `get_scaler_and_model` фрла `FileNotFoundError` исклучок со детализирано известување ако моделот или скаларот не можат да се најдат, обезбедувајќи појасни пораки за грешки кога нешто не е во ред при вчитување. 

**Причина**: Ова ја подобрува јасноста на пораките за грешки, што го прави процесот на дебагирање полесен.

**Предобработка на податоци и пресметка на технички индикатори:**

**Пред факторирање**: Логиката за пресметување на технички индикатори беше напишана во функцијата `calculate_time_frames` и беше инлајнирана низ целиот код.  

**По факторирање**: Клучната логика за пресметување остана во голема мера непроменета, но сега ја рефакториравме за целата логика да биде поорганизирана. Главните промени се поврзани со подобро ракување со и организирање на податоците, како што е осигурувањето дека сите потребни колони (Цена, Волумен) се присутни и ракувањето со случаи кога нема доволно податоци за одредени индикатори.  
**Причина**: Овој дел беше организиран за подобра читливост и за да се спречат проблеми со типови на податоци и недостасувачки вредности.

**Ресетирање на DataFrame:**

**Пред факторирање**: Подготовката беше направена во функцијата `calculate_time_frames`, но DataFrame-от што беше враќан не беше секогаш добро структуриран.  
**По факторирање**: По извршувањето на "resampling" логиката (подлебата на податоците на дневно, неделно и месечно ниво), резултатите сега се ресетираат за да се осигураме дека структурата на DataFrame-от е соодветна за враќање во одговорот. 

**API Endpoints:**

**Пред факторирање**: Имаше рути за `/calculate`, `/price` и `/nlp`, секоја извршувајќи различни задачи како пресметка на технички индикатори, предвидување на цените на акциите и обезбедување на анализа на сентимент.  
**Потоа**: Рутите останаа во голема мера исти, но сега интегрираат модулизираната логика од `ModelLoaderFactory` и подобрено ракување со грешки.

## Spring APP Рефакторирање

**HttpService за HTTP комуникација**  
**Пред факторирање**: FlaskService директно управуваше со HTTP барањата користејќи `RestTemplate` во истата класа. 

**По факторирање**: Ја воведовме `HttpService` класата за управување со HTTP комуникацијата, додека `FlaskService` се потпира на `HttpService` за испраќање на барањата. Ова обезбедува разделување на одговорностите (Separation of Concerns), што ја прави секоја класа пофокусирана на нејзината одговорност и полесна за одржување. `HttpService` исто така овозможува повторна употреба и тестирање на HTTP слојот без да се меша со бизнис логиката.

**Подобрување на управувањето со грешки преку ResponseStatusException**  
**Пред факторирање**: Во случај на грешки, сервисот фрлаше генерален `RuntimeException`. Сега, воведовме `ResponseStatusException` за фрлање на појасни HTTP статуси и пораки врз основа на типот на грешката. Ова овозможува подобро известување за грешки и конзистентно управување со истите низ целата апликација. Со користење на `ResponseStatusException` и глобален обработувач на исклучоци, се создава стандардизиран начин за ракување со грешки.

**Рефакторирање за подобрена одржливост**  
Методите `prepareStockData` и `parsePrice` беа тесно поврзани со логиката за обработка на акции. Сега, ги разделивме во помали помошни методи. Ова ги подобрува читливоста и тестирањето.

**Моделот CompanyData со валидациски анотации**  
Претходно, класа `CompanyData` немаше валидациски анотации. Сега, се користат анотации како `@NotEmpty` и `@Pattern` за да се осигураме дека влезните податоци се валидни пред да се обработат. Ова го подобрува интегритетот на податоците и обезбедува централизирана валидација.

**Употреба на Optional за ракување со null вредности во HTTP одговори**  
**Пред рефакторирање**: `FlaskService` проверуваше дали одговорот е null и фрлаше исклучок. 

**По факторирање**: Сега, `HttpService` враќа тип **Optional**, а `FlaskService` користи **Optional.orElseThrow()** за безбедно ракување со null одговори. Ова овозможува безбедност при ракувањето со отсутност на вредност и го подобрува протокот на програмата.

**Дизајн Патерни:**

**Template Method:** Класата `HttpService` е добар пример за шемата Template Method. Таа обезбедува основна структура за правење HTTP барања (т.е. `postForObject`), но овозможува и флексибилност со прифаќање различни типови на одговори (класата `Class<T>`). Оваа шема овозможува да ги дефинираме неизменливите делови на алгоритмот (како што е користењето на `RestTemplate` и правењето на POST барањето), додека варијациите (како што е ракувањето со одговорот) се оставени на повикувачкиот код.

**Singleton Pattern (за `StockServiceImpl`):** Класата `StockServiceImpl` следи и едноставен пример на шемата Singleton, каде што објектот `DatabaseFetchStrategy` се креира само еднаш и се користи за сите барања понатаму така што секое барање нема да е во конфликт и да користи посебен сервис. 

**Model-View-Controller (MVC) Pattern:** Апликацијата, како и генерално секоја Spring Boot апликација, е структурирана во согласност со MVC дизајн шемата:

- **Модел (Model):** Логиката поврзана со податоците (како што се `CompanyData`, `Stock`, и `TechnicalIndicatorsResponse`) го претставува модел слојот.
- **Поглед (View):** Податоците можат да бидат испратени до фронтенд (view) за прикажување. Овие податоци овдека не се испраќаат во конкретна HTML форма бидејќи за фронтенд имаме React апликација која ги прикажува податоците од Spring апликацијата. Но пак е запазена комуникацијата помеѓу моделот и погледот.
- **Контролер (Controller):** Класите `StockController`, `LSTMController` и тн. испраќаат и примаат податоци од и до моделот.

**Стратегиски Патерн во StockService**

**По факторирање:** Воведовме стратегиска интерфејс класа `StockDataFetchStrategy` за извлекување на податоци за акциите, со имплементација која ја користи базата на податоци. 

**Причина:** Стратегиската шема овозможува флексибилност во менувањето на стратегии за извлекување податоци без да се модифицира основната логика на сервис класата.

**Фабричка шема во StockController**

**По рефакторирање:** Креиравме фабрички метод (`setFetchStrategy`) кој овозможува контролерот да избере соодветна стратегија за извлекување податоци, базирано на моменталните потреби.

**Причина:** Ова овозможува лесно инстанцирање на различни типови на контролери и ракување со генерирање на одговори (JSON/XML) врз основа на преференциите на клиентот.

**Рефакторирање на Контролери за Користење на еден RestTemplate**

**По рефакторирање:** Во оригиналниот код, секој од нашите контролери (`NLPController` и `LSTMController`) креираше нова инстанца на `RestTemplate` секогаш кога ќе примеше барање. Ова е неефикасно, бидејќи `RestTemplate` е класа која е безбедна за повеќе нишки и може да се користи повторно за повеќе барања. Наместо да се креира нова инстанца на RestTemplate во секоја метод на контролер, одлучивме да го користиме инјектирањето на зависности на Spring за да споделиме една инстанца на `RestTemplate` низ целата апликација.

**Причина:** Овој пристап ја намалува потрошувачката на ресурси, ги подобрува перформансите и го прави кодот почист и полесен за одржување. Со повторната употреба на истата инстанца на RestTemplate, апликацијата подобро ги користи меморијата и процесорските ресурси.

- **Инјектирање на RestTemplate:** Инјектирање на зависности во Spring за да се инјектира `RestTemplate` bean во контролерите наместо рачно да се инстанцира.
- **Организирање на структурата на пакетите:** Конфигурациската класа (`RestTemplateConfig`) ја поставивме во пакетот `config`, следејќи ги вообичаените практики на Spring за подобра организација.

## React APP Рефакторирање

**Подобрено Ракување со Грешки од API:** Додадовме проверка за да се осигураме дека статусот на одговорот е во ред (response.ok). Ако не е, се прикажува порака во конзолата. Исто така, ако повикот кон API не врати податоци, сега апликацијата прикажува резервна порака за ова.

**Порака за Немање Податоци:** Вклучена е порака „Нема податоци за покажување“ кога нема достапни податоци, а состојбата `isLoading` е поставена на `false`.

**finally Блок за Чистење:** Поставувањето на `setIsLoading(false)` е преместено во `finally` блокот, со што сме сигурни дека ќе се изврши без разлика дали барањето било успешно или не.

**Консолидација на CSS Класи:** 

Рефакторираната верзија ја подобрува читливоста, ракувањето со грешки и повратните информации за корисниците, додека ја одржува функционалноста и ја подобрува структурата на кодот за полесно одржување.

**Направени Промени:**

**Подобрена Структура на JSX:** Ги отстранивме непотребните празни големи загради и ја исчистивме структурата на JSX за да се направи распоредот појасен и полесен за читање.

**Користено h1 за Наслов на Страницата:** Заменет е `div` со класата `page-header` со таг `h1` за подобра семантика.

**Додадена CSS Класа за Слика:** Сликата е обвиткана во контејнер (`image-container`), а додадена е класа `home-page-image` за стилизирање, што го олеснува контролирањето на распоредот и дизајнот во CSS.

**Подобрено Секционирање:** Ги групиравме поврзаните компоненти (наслов, текст, слика), со што се подобрува вкупната структура и се олеснуваат идните измени.

**Поедноставување на map Функцијата:** `menuItems.map` е задржано, но е структурирано за појасно прикажување на секој блок на податоци (икона, id, наслов и патека).
